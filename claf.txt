Intraserver

Once decrypted, Concord messages can be interpreted in any agreed-upon way.
Included in the core framework is a standard for controlling specifically the
access management elements of a chat server. Below, CLAF (the Concord Limited Access Format):

Any message will have the following characteristics:

{
    a: author tripcode,
    h: hash of timestamp + server tripcode + for each parent block, that block's hash
    st: message supertype,
    d: message data
}
#note: the point of including a hash is to "sign" the content's full context.
# you can spoof a new copy of a signed message, which might have a different meaning when sent at a different position.
# however, if two blocks have exactly the same particulars (INCLUDING parent blocks, timestamps, all content, and server trip)
# they're identical (and will even have the same block hash)
Four supertypes exist:
- "c", for independent content (messages, links, images, etc; see cmark.txt)
- "a", for access-affecting content; this section includes successor server creation, member additions, and such.
- "r", for permissions-affecting content (expressed in terms of named roles)
- "s", for settings-affecting content (not connected to chain interpretation, but strung together into one settings object)
Of course, independent content can have any data.
However, for the other four supertypes, a fixed set of actions can be invoked.
In these cases, a "t" feature describing type will exist, and data will be prescribed by that type.
---
Access
-----
t: "nserv" - create a new server (will be ignored if not first message)
d: {
    cms: {
        enc_pubk: RSA public key,
        sig_pubk: DSA public key
        (both for server creator)
    }
    prev_key: predecessor server AES key (if applicable)
}
t: "invite" - invite one or more users to the server
d: {
    nms: [for each member, {
        enc_pubk: RSA public key,
        sig_pubk: DSA public key
    }]
}
#note: hash sig_pubk+enc_pubk to get member trip
t: "rem" - forward to a new server lacking one or more users
d: {
    rms: [removed member tripcodes],
    nst: new server trip,
    archive: [head block hashes, not including this one or its parents],
    nsk: {
        (preserved) member trip: RSA-encrypted AES key for new server
    }
}
---
Permissions
----
Permissions are expressed as a single b64 char, encoding 6 bits, alongside an integer expressing role power.
0 - Is muted
1 - Can invite
2 - Can remove less powerful users (user power = max role power)
3 - Can grant/remove less powerful roles
4 - Can create less powerful roles
5 - Can edit settings
#note: from the perspective of client, roles can do more than this. However, the client will need to implement other features by checking server roles and matching names with settings-based configuration.
# that is to say, these are the CLAF-level features of roles.
t: "crole" - create a role
d: {
    rn: role name (should be unique),
    rp: role primacy,
    pc: permissions char
}
t: "grole" - grant a role
d: {
    tu: target user trip,
    tr: target role name
}
t: "rrole - remove a role
d: symmetric with "grole" (same args)
---
Settings
----
t: "sset" - set settings
d: {
    sn: [[setting keys]],
    po: [bool - parse objects, defaults to true],
    sv: [setting values (JSON)]
}
t: "cset" - clear settings
d: {
    sn: [[settings keys]]
}

However, Concord is not a linear format, and consequently neither is CLAF.
This is not terribly disruptive when it comes to independent content messages - aside from the occasional branching when messages are sent simultaneously - but,
in server administration (the other three types), it makes a massive difference. If a user uses a role permission at the same time as that permission is revoked, what happens?
For most cases, CLAF relies on a simple procedure:
1. Messages are only affected by their predecessors
2. When splits containing parallel administrative messages are merged, the messages are executed in order of maximum role power.
3. "rem" messages are special in the following ways:
   i. They're powerful and permissions associated with them should be granted with caution (they create new servers!)
   ii. They're adhered to by everyone whenever permitted within their own branch (i.e. they prevent merging, even merging that could cancel them)
   iii. They kill all server messages that don't rely on them (not a problem usually; this is done to prevent server activity post-rem)
As long as branches are quickly resolved in the end, this allows users to act without infringing on the operational integrity of the server.